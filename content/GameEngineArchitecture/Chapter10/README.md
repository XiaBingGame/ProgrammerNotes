## 10.1 采用深度缓冲的三角形光栅化基础
* 有些表面可以用分析式来精确表示. 如球面.
* 电影产业,表面由面片(patch)组成,面片由少量控制点定义的三维样条(spline)所构成. 有 Bezier 曲面, 非均匀有理 B 样条(nonuniform rational B-spline, NURBS), N 面片(N-patches, 又名 normal patches).
* Pixar 的 RenderMan, 采用细分曲面(subdivision surface)定义几何形状.
* tessellation 把表面分割为一组离散多边形. 实现三角形对像素密度. 表面根据与摄像机的距离进行 tessellation, 使每个三角形的尺寸小于一个像素.
	- 生成不同 LOD 的三角网格链
	- 渐进网格(progressive mesh)是另一种动态镶嵌及层次细节技术. 物体接近摄像机时采用单个最高分辨率网格. 远离摄像机时,网格自动密铺,即某些棱收缩为点.
* 可见光的波长是 740nm~380nm
* 光只会做4种事情: 被吸收, 被反射, 在物体中传播(折射), 通过很窄的缺口(衍射)
* 反射是各向异性的, 在不同角度观察光的反射有所不同
* 光也能进入半固态的表面, 在表面下反弹, 再从另一个位置离开表面, 这个现象称为次表面散射(subsurface scattering, SSS). 此效果能使皮肤, 蜡, 大理石等物质显示其柔和的特性.
* 调色板格式(paletted format)可使用每像素8位存储索引,再用这些索引查找一个含有256色的调色板, 调色板的每笔记录可能存储为 RGB888 或其他合适的格式.
* 常见定点属性:
	* 位置
	* 法向量
	* 切线向量, 与副切线向量组成切线空间. 用于多种逐像素光照,如法线贴图和环境贴图等.
	* 漫反射颜色
	* 镜面颜色
	* 纹理坐标
	* 蒙皮权重
* 高氏着色法(Gouraud shading) --- 线性插值作用于顶点颜色上
* 纹理种类: 漫反射贴图(diffuse map), 法线贴图(normal map), 光泽贴图(gloss map), 环境贴图(environment map)
* 一维纹理可以存储复杂数学函数的采样值
* 纹理格式: TGA, PNG, BMP, TIFF
* 压缩纹理(compressed texture), 基本原理把纹理切割成多个4像素x4像素的小块,并用一个小型调色板(color palette)存储每个小块的颜色
* 有时候压缩纹理渲染更高效, 如每个小块把 4x4 个相邻像素存储至单个 64 位或 128位字中,因此能够更充分的利用缓存.
* 纹素密度 --- 纹素和像素之比, 通过多级渐远纹理(mipmap)技术控制纹素密度接近为1.
* 世界空间纹素密度尽量保持一致, 否则容易被觉察出来.
* 顶点属性并不算是材质的一部分, 材质是网格视觉特性的完整描述,包括贴到纹理表面的纹理设置,选用哪个着色器, 输入参数等.
* 三维模型通常会使用多于一个材质,如一个人类模型可能有多个材质,供头发,皮肤,眼睛,牙齿,多种服饰等之用.
* 着色(shading), 光照加上其他视觉效果的泛称. 着色包含了过程式的顶点变形(水面动态), 生成毛发曲线或皮毛外壳(fur shell), 高次曲面(high order surface)的镶嵌, 以及许多渲染场景所需的计算.
* 光传输模型(light transport model): 通过数学模型来模拟光和表面/体积的交互作用.
* 直接光照模型(direct lighting model): 光发射后, 碰到场景中某个物体后会反射, 然后直接进入虚拟摄像机的虚拟平面. 也称之为局部光照模型(local illumination model)
* 局部光照模型(local illumination model): 仅考虑光对单个物体的局部影响, 换句话说, 此模型中每个物体不会影响其他物体的光照.
* 间接光照(indirect lighting): 光被多个表面反射后才进入摄像机.
* 全局光照模型(global illumination model): 照顾到间接光照的模型.
* 全局光照模型针对的视觉现象:
	* 逼真的阴影
	* 模拟反射性表面
	* 考虑物体间的互相反射(某物体的颜色会影响其邻近物体的颜色)
	* 模拟焦散(caustics)效果(水面或光滑金属表面的强烈反射)
* 全局光照模型的光学现象:
	* 光线追踪(ray tracing)
	* 辐射度算法(radiosity)
* 渲染方程(the rendering equation)或着色方程(shading equation)
* Phong 氏光照模型
* Blinn-Phong 氏光照模型
* BRDF 图表: Phong 反射模型是通用的双向反射分布函数(bidirectional reflection distribution function, BRDF)的特例. BRDF 是视线方向V的向外(反射)辐射与沿入射光线L的进入辐射之比. P429展示了phong模型漫反射和镜面反射的BRDF函数.
* 光源模型
	- 静态光源: 预先计算光源. 在网格顶点预先计算Phong反射,结果存储于顶点的漫反射颜色属性中. 还可以逐像素预计算光照, 把结果存储于名为光照贴图(light map)的纹理贴图中.
		- "纯"光照贴图通常比包含漫反射颜色信息的贴图更易压缩.
	- 环境光(ambient light): Phong 光照模型中的环境项
	- 平行光(directional light)
	- 点光/全向光: point light/onmidirectional light. 通常以光源距离做平方衰减
	- 聚光: spot light, 有内角和外交设置两个圆锥, 内圆锥, 光线以最高强度发射,内角和外角之间,光线的强度会衰减.
	- 面积光: 产生的阴影含有本影(umbra)和半影(penumbra)
		- 小技巧: 投下多个阴影, 再把结果混合生成半影. 或者把锐利的阴影边缘模糊化.
	- 发光物体: 发光表面可使用放射光贴图(emissive texture map)来模拟, 此纹理的颜色永远以完全强度发射,不受附近的光照环境所影响.这种纹理可以用来定义霓虹灯标志,车头灯等.
		- 结合多种技术: 直望的方向使用放射光贴图,同一位置加入聚光以照亮场景,加入半透明的黄色网格模拟光锥, 渲染面向摄像机的卡片模拟镜头光晕(len flare), 用投射纹理把手电筒的焦散效果投射至受光的表面上. 见任天堂的<路易士鬼屋>.
* 虚拟摄像机
	- 齐次裁剪空间使用左手坐标系, 因为z轴随深度递增而递增, 对于opengl, 近平面的z值为-1, 远平面的z值为1.
	- 透视校正的顶点属性插值: 属性插值在屏幕空间中进行的,需要谨慎处理透视投影的插值, 考虑透视收缩的影响计算. 这种称之为透视校正插值(perspective-correct interpolation), 具体见参考文件[28]
	- 光栅化(rasterization): 给三角形范围内的像素填充数据. 在光栅化过程中,三角形表面会被拆成名为片段(fragment)的小块,每个片段对应三角形表面中的一个细小区域,而每个这些细小区域对应单个屏幕像素(多采样抗锯齿时,每个片段对应于像素的一部分)
	- 深度缓冲(z-buffer)
	- 深度冲突(z-fighting): 两个比较接近的深度值产生的冲突.
	- 由于裁剪空间远近距离的物体深度值精度不一致, 应此希望在深度缓冲中存储观察空间的z坐标. 该技术称之为w缓冲(w-buffer). w缓冲相对耗时, 因为需要先计算深度的倒数才能进行插值, 这是因为w值和深度值互为倒数.

## 10.2 渲染管道
* 管道(pipeline): 一连串的顺序计算阶段(stage), 每个阶段有其具体目的,各个阶段会操作输入流中的数据项,并对输出流产生数据
* 管道最高级的阶段:
	- 工具阶段(脱机): 定义几何和表面特性(材质)
	- 资产调节阶段(脱机): 资产调节管道处理几何和材质数据,生成引擎可用的格式
	- 应用程序阶段(CPU): 识别出潜在可视的网格实例,并把它们及其材质呈交至图形硬件以供渲染
	- 几何处理阶段(GPU): 变换顶点,照明, 然后投影至齐次裁剪空间.可以选用几何着色器处理三角形,然后对三角形根据平截头体进行裁剪
	- 光栅化阶段(GPU): 吧三角形转换为片段,并对片段着色.片段经过多种测试后,最终和帧缓冲混合.
* 流输出: 有些GPU允许GPU管道几何着色器阶段的数据写回内存, 数据能从这里回到管道开始的地方做进一步处理.
	- 可以实现头发(三次样条曲线)的渲染. GPU可以在顶点着色器内,在头发样条的控制点上进行物理模拟,几何着色器把样条镶嵌成线段,并用流输出功能把镶嵌后的顶点数据写入内存,最后那些线段被重新流入管道开始的地方进行渲染.
* 三角形遍历(triangle traversal)阶段把三角形分解为片段(即光栅化). 
	- 通常每个像素会产生一个片段, 但在一些抗锯齿技术中, 每个像素可能产生多个片段.
	- 三角形遍历会对定点属性进行插值,产生每片段(per-fragment)属性,供像素着色器使用.
	- 有需要时,会采用透视校正插值.
	- 此阶段的功能也是固定且不能配置的.
* 提前深度测试: 在三角形遍历后检查片段的深度,以跳过像素着色器阶段. 称为提前z测试(early z-test)或提前深度测试(early depth test).
* 管道的最终阶段为合并阶段(merge stage)或混合阶段(blending stage). NVIDIA 称之为光栅运算阶段(raster operations stage, ROP), 此阶段不能编程, 但能高度配置. 负责执行多个片段测试,包括深度测试,alpha测试,模板测试.
	- 进行 alpha 混合时, 新片段的深度会覆写帧缓存内的深度值, 除非关掉了深度写入. 所以透明物体需要从后往前的顺序进行渲染.
* 可编程着色器:
	- 几何着色器的输入为单个n顶点几何图元---点(n=1), 线段(n=2), 三角形(n=3), 以及最多n个做为控制点的额外顶点. 其输出为0或多个图元,这些图元的种类可与输入的有所不同.
	- 着色器的内存访问只限于两个方法: 寄存器和纹理贴图
		- 着色器寄存器: 所有 GPU 寄存器都是128位SIMD格式的,每个寄存器都能保存4个32位浮点数或4个32位整数. cg 用 float4 表示4个32位浮点数, float4x4表示内置矩阵. 寄存器有4大类:
			- 输入寄存器(input register): 顶点属性
			- 常数寄存器(constant register): 一致变量
			- 临时寄存器(temporary register): 着色器内部使用的变量
			- 输出寄存器(output register): 顶点着色器和片段着色器的输出.
		- 变换后顶点缓存(post-transform vertex cache): 存储顶点着色器最近处理过的结果.(GPU通常会把输出数据存储至缓存,是这些数据能重用而不需要重新计算)
		- 纹理
			- 当纹理贴图作为查找表使用时,关上过滤功能很有用
* cg 着色器
	- 语义(semantic): 可以在变量或 struct 成员之后加入冒号和一个名为语义的关键词, 语义告诉编译器如何把变量或数据成员绑定至个别顶点或片段属性
```
	struct VtxOut
	{
		float4 pos		: POSITION; // 映射至位置属性
		float4 color	: COLOR;	// 映射至颜色属性
	}
```
	- 若变量是以参数形式传入着色器的主函数的,那么它就会被当作输入;若变量是主函数的传回值,那么它就会被当作输出.
```
	VtxOut vshaderMain(VtxIn in)	// in 映射至输入寄存器
	{
		VtxOut out;
		// ...
		return out;					// out 映射至输出寄存器
	}
```
	- uniform 一致变量
```
	VtxOut vshaderMain(VtxIn in,
						uniform float4x4 modelViewMatrix)
	{
		VtxOut out;
		out.pos = mul(modelViewMatrix, in.pos);
		out.color = float4(0, 1, 0, 1);
		return out;	
	}
```
	- 获取纹理数据
```
	struct FragmentOut
	{
		float4 color : COLOR;
	}
	FragmentOut pshaderMain(float2 uv : TEXCOORD0,
							uniform sampler2D texture)
	{
		FragmentOut out;
		out.color = tex2D(texture, uv);
		return out;
	}
```
* 效果文件: 组合多个着色器文件. Cg 格式为 CgFX, ORGRE 使用材质文件. 效果文件通常的层次结构:
	- 全局作用域定义 struct, 着色器程序(实现为多个"主"函数), 全局变量
	- 一种或多种技术(technique), 以兼容低级的图形硬件.
	- 每种技术内部定义一个或多个pass, 每个pass描述如何渲染一整帧影像, 通常一个 pass 包含顶点/几何/像素着色器的"主函数"引用,多个参数绑定及可选的渲染状态设置.
	- 具体见 NVIDIA的 cg 教程
* 抗锯齿
	- 全屏抗锯齿(full-screen antialiasing, FSAA), 又称之为超采样抗锯齿(super-sampled antialiasing, SSAA): 把场景渲染至比实际屏幕大的帧缓冲中, 渲染完一帧后, 就把扩大了的结果图像向下采样(downsample)至目标分辨率, FSAA是极其昂贵的技术, 很少用于实际场合.
	- 多重采样抗锯齿(multisampled antialiasing, MSAA)
		- 首先了解光栅化如何工作: (1)判断哪些像素与三角形重叠(覆盖); (2)判断像素是否被其他三角形遮挡(深度测试); (3)当覆盖和深度测试告诉我们实际上要绘制哪个像素后,计算该像素的色彩(像素着色).
		- MSAA中, 覆盖测试和深度测试分别在每个像素中N个点上执行, 这些点被称为子样本(subsample). N 通常为2, 4, 5, 8, 16. 无论多少样本, 像素着色器只对每个屏幕像素执行一次.
		- N x MSAA 中, 深度,模板,色彩缓冲都是原始的N倍大,每个屏幕像素在这些缓冲区内包含N个"槽",每个槽对应一个子样本.光栅化时,像素着色器的计算结果仅存储至那些通过了覆盖测试和深度测试的样本槽内. 渲染完整个场景后,向下采样那个扩大了的色彩缓冲,最终获得屏幕大小的图像.
	- 覆盖采样抗锯齿(coverage sample antialiasing, CSAA): NVIDIA 针对 MSAA 优化的技术.
		- 4 x CSAA中, 着色器每个像素只执行一次,深度测试和色彩存储对每个片段的4个子样本执行. 像素覆盖测试则在每个片段对16个"覆盖样本"执行.
		- 4 x CSAA, 接近 8x 或 16x MSAA 的想过, 却只需要 4x MSAA de 显存和GPU成本
	- 形态学抗锯齿(morphological antialiasing, MLAA): 修正场景中最受混叠(走样)影响的区域, 就是找出这些锯齿状区域的图像模式, 通过模糊化去降低混叠效果.
* 应用程序阶段(application stage)
	- 本阶段的三个角色:
		- 可见性判别: 仅把可见的物体提交给GPU
		- 提交几何图元至GPU以供渲染
		- 控制着色器参数及渲染状态
* 可见性判断
	- 平截头体剔除: 通过比较平截头体的六个面和物体的包围体判断是否可见. 通常包围体是个球体.
	- 遮挡及潜在可见集
		- 遮挡剔除(occlusion culling)
		- 预计算潜在可见集(potentially visible set, PVS). 给定一个摄像机位置,PVS能列出可能可见的物体. 实现方法之一就是把场景切割成某类型的区域,每个区域提供摄像机在该区域内能看见的其他区域列表.
	- 入口(portal): 游戏世界会划分为半封闭的区域, 这些区域以孔洞互相连接, 例如窗户或门户, 这些空洞称之为入口, 通常会以其边界的多边形表示. 通过摄像机位置和入口多边形延伸建立包围多边形的入口体, 通过该入口体积进行剔除.
	- 遮挡体积(反入口): 将入口的概念反转,锥形的体积描述某物体遮挡的区域, 这些区域内的物体不会被看见. 这种体积称为遮挡体积(occlusion volume)或反入口(antiprotal).
* 提交图元
	- 状态泄漏: 如果在提交图元的过程中, 我们忘记设置某方面的渲染状态, 那么上一图元的设置变回"泄露"至下一图元.
	- 通过调用 DirectX 的 DrawIndexedPrimitive() 或 OpenGL 的 glDrawArrays() 提交图元. 这些 API 的调用成本本身对于某些应用程序来说可能太高, 为了优化性能, 有些游戏引擎会手工建立 GPU 命令表, 或调用底层的渲染API, 如PS3 的 libgcm 库.
* 几何排序: 尽可能减少渲染状态的改变. 按材质排序几何物体. 但这样容易产生覆绘(overdraw)---多个互相重叠的三角形重复填充同一像素.
	- 提前进行深度测试,以预先丢弃被遮挡的像素,避免执行耗时的像素着色器.因此我们需要从前往后的顺序渲染三角形.离摄像机最近的三角形会立即填充深度缓冲,后续较远三角形的所有片段都会被迅速丢弃,最终导致很少甚至全无覆绘.
	- 深度预渲染步骤(z prepass)功能. 基本概念是渲染场景两次, 第1次尽量快速地产生深度缓冲的内容,第2次才用完整的颜色填进帧缓冲. 当关闭像素着色器仅更新深度缓冲绘制第一遍, 这个时候物体可以按照从前往后的顺序绘制,以减少深度缓冲区的写入.然后几何物体按照材质重新排序,用最少的状态改变渲染颜色,即第2次渲染.`
	- 次序无关透明(order-independent transparent): 令透明几何体以任意次序渲染. 在每个像素中存储多个片段, 在场景渲染后, 逐像素进行排序及混合. 问题是帧缓冲需要足够大以存储每个像素的所有透明片段,因此内存成本较高.
* 场景图: 方便迅速丢弃大量完全不接近摄像机平截头体的世界部分. 同时能够帮助对场景的几何物体排序, 如为了深度预渲染做前至后或后至前排序, 或为了颜色渲染采用材质排序.
	- 例子有:四叉树, 八叉树, BSP树, kd 树, 空间散列技术(spatial hashing)等.
	- 四叉树或八叉树:尽量令每个叶节点有均匀的图元数量,可基于区域内的图元数量来决定继续还是终止细分区域.
	- 包围树球: 把空间以层次结构分割为球状区域, 子节点含有场景中可渲染图元的包围球,把图元分成小组,计算每组的包围球.然后这些小组再结合成较大的组,重复此过程,直至得到一个包围整个虚拟场景的包围球.
	- BSP树,二元空间分割(binary space partitioning, BSP)树把空间递归分割为一半,直到每个半空间(half-space)里的物体符合某些预订条件.
		- BSP 树有多种用途,包括碰撞检测和构造实体几何(constructive solid geometry, CSG),以及其最知名的优化三维图形用途(平截头体剔除及几何物体排序).
		- kd树是BSP树的特殊情况.BSP的分割平面是任意方向的,kd树的分割平面会依次与k维空间的轴对齐.
		- BSP树在每层递归中使用单个平面把空间二分,常用场景中某三角形的平面分割空间.
		- BSP树可以使三角形从后至前或从前至后的严格次序排序.

## 10.3 高级光照及全局光照
### 10.3.1 基于图像的光照
* image-based lighting 算法
* 法线贴图(normal map)
* 高度贴图(heightmap): 每个纹理只需单个高度值. 高度贴图可用于凹凸贴图法(bump mapping), 视察遮挡贴图法(parallax occlusion mapping), 位移贴图法(displacement mapping)
	- 现在大多数引擎直接把法矢量存储于法线贴图,不再通过高度图生成
	- 视差遮挡贴图, 使用高度贴图的信息人工调整纹理坐标,令平坦表面随摄像头移动时能显示出正确的表面细节移动.
	- 位移贴图(也称之为浮雕贴图, relief mapping). 通过实际镶嵌及挤出表面多边形产生真实的表面细节.它能产生自遮挡及自阴影,生成真正的几何细节.
* 镜面/光泽贴图
	- 许多镜面并不是均匀光滑的,例如,当人的脸上有汗或污垢时,湿润的区域显得有光泽,干燥的区域则显得暗淡.可以把非常细致的镜面信息编码至一张贴图中,此贴图为镜面贴图(specular map), 
	- 镜面强度的数学形式为 Ks(R*V)^a, 当纹理存储的是Ks值时,该镜面贴图有时被称为光泽贴图(gloss map), 或镜面遮罩(specular mask). 如果纹理存储a的值,则可以控制每纹素位置镜面高光的集中程度,这种纹理称之为镜面幂贴图(specular power map).
* 环境贴图(environment map)
	- 两种环境贴图格式: 球面环境贴图(spherical environment map)及立方体环境贴图(cubic environment map), 球面贴图的问题是使用球坐标(spherical coordinates)进行寻址,在赤道附近,水平和垂直方向都有足够的分辨率.然而在垂直角度(方位角,azimuthal angle)接近垂直时,水平(天顶,zenith)轴方向的纹理分辨率变回降至单个纹素.
* 三维纹理

### 10.3.2 高动态方位光照
* 使用 HDR 光照时, 结果影像会以某种格式保存, 这种格式允许存储大于1的强度. 无失真地同时保存亮区和暗区的细节.
* HDR影像显示于屏幕之前,进行色彩映射(tone mapping)处理.把影像的强度调整至显示设备所支持的范围.
	- 仿造现实世界的效果,从黑暗房间中走到明亮区域所造成的短暂失明现象,或是看到很强的背光从物体边缘溢出(覆霜效果,bloom effect)
	- HDR影像的表示方法:红绿蓝各通道存储为32位浮点数.或用不同的色彩模型, log-LUV色彩模型, 强度(intensity)通道和两个色度(chromaticity)通道(U及V)来表示.L使用16位存储,U和V都使用8位存储,此外L是以对数(底数为2)表示的,以捕捉非常大范围的光强度.

### 10.3.3 全局光照
* 阴影渲染
	- 常见阴影技术:阴影体及(shadow volume)和阴影贴图(shadow map)
	- 阴影体涉及到了stencil的使用.
	- 阴影贴图通过光源的深度图实现.
* 环境遮挡(ambient occlusion, AO)是一种用于渲染接触阴影(contact shadow)的技术.接触阴影为仅以环境光照明时所产生的软阴影.
	- AO描述表面上每点"可接触光线"的程度. 例如一根管子的内部表面比外部表面能接受到的环境光照要少.
	- 计算某点AO的方法,以该点为求心,设置一个半径非常大的球体,计算从该点可见的半球表面面积,可以离线预计算, 计算结果存储为纹理.
* 镜像
	- 环境贴图可用于一般光滑物体表面上产生附近环境的镜像
	- 平面物体(如镜子),则可以把摄像机位置按该反射性表面进行反射变换, 然后从反射的视点渲染场景至一张纹理, 而后再把该纹理渲染至该反射性表面上.
* 焦散(caustics)是指强烈反射或折射所产生的光亮高光.通常出现于非常光滑的表面, 如水面或抛光金属. 当反射的表面在移动时,例如水面的抖动,焦散会产生闪烁及在投射的表面上"摇曳".
	- 要渲染焦散效果,可通过投影一张含有(具动画的)半随机亮点的纹理至受影响的物体表面.
* 次表面散射,当光线到达物体表面上的一点时,光线会在表面下散射,然后在表面的其他位置离开,此现象称为次表面散射(subsurface scattering, SSS). SSS现象令人体皮肤,蜡,大理石等材质表面产生"温暖,淡淡发光"的效果.
	- SSS可以用比BRDF更高阶一些的变种表示,此函数称之为双向表面散射反射分布函数(bidirectional surface scattering reflectance distribution function, BSSRDF).
	- SSS可以用深度贴图实现,测量光线需要经过多少距离才能通过此遮挡物,然后在物体的阴影面上加入人造的漫射光照项,其光照强度与光线经过物体至另一面的距离成反比.
* 预计算辐射传输(precomputed radiance transfer, PRT), 实时模拟基于辐射度算法的渲染算法.预先计算来自所有方向的入射光和表面的互动(反射,折射,散射).并把那些描述存储下来.在运行时,根据某入射光线查找表,并把该光线的反射迅速转换为准确的光照结果.
	- 球谐基函数(spherical harmonic/SH basis function)的线性组合逼近模拟光在某点的反射.
* 延迟渲染(deferred rendering), 主要的光照计算是在屏幕空间进行的,而非观察空间.
	- 我们首先迅速地渲染不含光照的场景. 在此阶段, 我们把所有将用于光照计算的信息存储在一个"深厚的"帧缓冲里, 此缓冲区称为几何缓冲(geometry buffer, G-buffer).完成场景渲染后,使用几何缓冲的信息来计算光照和着色.
	- 典型的几何缓冲可能含有以下属性:深度,观察空间或世界空间的表面法矢量,漫反射颜色,甚至是预计算辐射(PRT)系数.
* 基于物理着色(physically based shading)模型.  https://www.marmoset.co/toolbag/learn/pbr-theory

## 10.4 视觉效果和覆盖层
* 粒子效果
* 贴花(decal): 是覆盖在场景中正常物体上相对较小的几何物体,用于动态改变物体表面的外观.弹孔,脚印,抓痕,裂缝等都是贴花的例子.
	- 实现方法: 贴花设为长方形区域,按某方向投影在场景中,形成一个三维空间中的长方体.长方体在投射表面与表面第一次相交的地方就成为贴花的面片. 然后提取三角形, 生成适当的顶点纹理坐标. 加上深度偏移解决深度冲突.
* 由于像素着色的成本过高, 可以渲染其他场景后在渲染天空.渲染天空可以关闭深度写入,用一个小于最大值的z值表示天空的深度.
* 天空穹顶(sky dome)或天空盒(sky box)
* 云技术:公告板, 基于粒子效果的云, 体积云(volumetric cloud).
* 高度场地形(height field terrain), 通常存储为灰阶纹理贴图.
* 地形系统可以用专门的工具"粉刷"地形数据, 雕刻不同的地形特征.
* 瀑布可能使用专门的水体着色器,卷动纹理,模拟雾的粒子效果,模拟水泡的类贴花覆盖等.
* 平视显示器(HUD), 覆盖层(overlay)
* 归一化坐标支持不同分辨率的显示器,两个轴的一个轴的范围由0到1, 通常y轴的范围为0.0-1.0, 当4:3屏幕时,x轴范围为 0.0-1.333
* 使用屏幕相对坐标
* 字体(font)通常以含有字形的纹理贴图实现,另外,再保存一个字体描述文件,内含每个字形在纹理中的包围盒,字体布局的信息,如字距调整(kerning),基线偏离(baseline offset)等.
* 纹理贴图所使用的位图通常本身已获伽玛校正,因此要考虑进行伽玛解码
* 全屏后期处理效果
	- 动态模糊(motion blur):渲染一个屏幕空间的速度矢量缓冲区,使用该矢量场选择性地模糊已渲染的影像.
	- 景深模糊(depth-of-field blur):使用深度缓冲区的内容调整每像素的模糊程度
	- 晕影(vignette): 降低屏幕四角的亮度和饱和度,产生类似电影的戏剧性效果.
	- 着色(colorization): 任意方式修改屏幕上的颜色.
* 延伸阅读
	- 三维计算机图形及动画的整个过程概览: Isaac Victor Kerlow. The Art of 3-D Computer Animation and Imaging (Second Edi-
tion). New York, NY: John Wiley and Sons, 2000.
	- 当代实时渲染技术: Tomas Akenine-Moller, Eric Haines and Naty Hoffman. Real-Time Rendering,
Third Edition. Wellesley, MA: A K Peters, 2008
	- 所有关于计算机图形学的权威参考指南: James D. Foley, Andries van Dam, Steven K. Feiner and John F. Hughes.
Computer Graphics: Principles and Practice in C, Second Edition. Reading, MA:
Addison-Wesley, 1995.
	- 其他好书:
		- Dante Treglia (editor). Game Programming Gems 3. Hingham, MA: Charles River
Media, 2002
		- David H. Eberly. 3D Game Engine Design: A Practical Approach to Real-Time Com-
puter Graphics. San Francisco, CA: Morgan Kaufmann, 2001.
		- David H. Eberly. 3D Game Engine Architecture: Engineering Real-Time Applications
with Wild Magic. San Francisco, CA: Morgan Kaufmann, 2005.
	- 有关三维渲染的数学知识: Eric Lengyel. Mathematics for 3D Game Programming and Computer Graphics, Sec-
ond Edition. Hingham, MA: Charles River Media, 2003.
	- Graphics Gems 和 GPU Gems
