# 第6章 纹理
* 给表面贴纹理可以使用两张纹理，第一张纹理改变表面的颜色，第二章纹理改变表面的粗糙度. 例如使用不同的粗糙度表现墙壁上的砖块和砖块之间的砂浆部分。使用 bump mapping 生成墙壁的凹凸不平效果。使用 Parallax mapping 使用一张纹理变形平坦的表面，parallax occlusion mapping 在一张高度场纹理上发射射线以提升真实度。Displacement mapping 通过修改三角形高度来移动表面。

![](Media/Figure_06_01.png)

上图中使用了纹理和bump map

## 1. 纹理管线

![](Media/Figure_06_02.png)

![](Media/Figure_06_03.png)

* 当纹理的颜色位于 sRGB 空间，在用与着色公式的过程中，应将其转换至线性空间。
* 常见的纹理投影有球形，圆柱形，平面投影。

![](Media/Figure_06_04.png)

    上图分别演示球形，圆柱形，平面，自然投影，底下一行则分别演示球形，圆柱形和平面投影。

* 纹理投影可以使用其他的输入，例如表面的法线可用于选择六个平面投影方向中的一个作为表面的纹理投影。通常在建模阶段使用投影函数设置顶点的投影结果，不过有时也根据需要在顶点和片段着色器中使用投影函数设置纹理坐标。
* 球面投影与环境映射方案(environment mapping scheme)使用的投影相同，可见(10.4.1节)。圆柱投影的水平纹理坐标u和球面投影相同，纵向纹理坐标v则圆柱轴方向上的距离。平面投影则使用正交投影将图像投影至表面上，可用于贴花。
* 美工通常将模型分解为接近平面的部分，或展开网格，或生成一组接近最佳的平面投影集解决纹理投影的变形问题，感兴趣的话可见Hormann的SIGGARAPH的课程笔记[774]
* 三维纹理使用(u,v,w)三元组坐标。当使用4元组坐标时，可以将q作为齐次坐标的第四个值，实现类似于将灯上的装饰图案投影到舞台或者其他物体表面上时的效果。
* 同时还有cube map和一维纹理，一维纹理可以确定一个地形中不同高度下的颜色，如山脚为绿色，山顶为白色。同时线条也可以使用纹理，将雨水渲染成带半透明图形的线条。
* Corresponder functions 将纹理坐标转换至纹理空间的位置。通常使用 API 函数实现该功能。如 GLSL 的 texture 函数。另一种类型的 corresponder 则为一个矩阵变换，在顶点或片段着色器中使用，允许表面上的纹理执行平移，旋转，缩放，切变，投影操作。注意的是变换矩阵的顺序应当和想要的顺序相反。
* 纹理坐标位于[0,1]之外的处理: wrap,repeat,tile; mirror; clamp; boarder.
* 隐式的 corresponder function, [0, 1] 映射至一张图像上。

## 2 图像贴图(Image Texturing)
* DirectX 纹理左上角(0, 0), 右下角(1, 1)。 OpenGL 纹理左下角(0, 0), 右上角(1, 1). DX10 和 DX9之前的浮点坐标计算不一样，通过裁剪掉小数部分得到浮点像素位置的像素值，即像素中心的位置为 (0.5, 0.5)
* dependent texture read --- 纹理坐标通过计算而来，纹理的坐标值依赖于之前纹理的值。
* 现代 GPU 可以处理任意大小的非2幂(non-power-of-two NPOT)纹理, 图形加速器有不同纹理大小的上限，DX12 允许最多处理 16384^2 个纹理。
* 只要着色器的纹理输入和其颜色输出为线性关系，这个过滤各自的纹理值等同于过滤最终的颜色值。但有些纹理的输入和着色器的输出不存在线性关系，如法线和粗糙度, 这里就不能直接过滤输入的纹理值。
* 放大的过滤有最近邻居和双线性插值过滤，还可以在着色器中实现对 4x4 或 5x5 的纹素数组进行三次方卷积过滤(cubic convolution)
* 为了解决纹理放大的模糊问题，我们使用更详细的纹理解决该问题，例如手机上的划痕，地形上的灌木丛之类的细节.
* 许多更高阶的过滤器可以表示为重复的线性插值。由于双三次过滤代价较高，可以使用平滑曲线在一组 2x2 纹素之间进行插值。两个常用曲线如下：

![](Media/Equation_06_01.png)

对于 smoothstep 曲线，其位于0和1处的一阶导数均为0，对于 quintic 曲线来说， 在此之外， 位于0和1处的二阶导数也为0. 将纹理坐标的小数部分用曲线重新生成,而后和整数部分一起重新使用双线性插值进行计算。

* 纹理的信号频率不要大于采样频率的一半。假设图像由交替的黑线和白线组成，每个一个纹素宽。则波长为2个纹素长，所以频率为0.5，为了能正确在屏幕上显示纹理，每个纹素至少覆盖一个像素，即每个像素至多有一个纹素。
* 对于 sRGB 纹理，应将 sRGB 转换为线性空间，在该空间内执行所有 mipmap 过滤，然后将最终结果转换回 sRGB 颜色空间进行存储。
* LOD 和 LOD bias 控制纹理 mipmap 的访问。
* mipmap 的主要问题是模糊过度(overblurring)， 尤其是当u方向和v方向的LOD差别很大时。
* 使用 summed-area table(SAT) 技术解决过度模糊问题。创建和纹理一样大小的数组，但每个元素的大小要大于颜色的存储精度大小，例如 16 位存储 RGB 的每个通道。每个元素存储从纹理原点位置到达该纹理位置处的矩形内所有纹素颜色值的总和。根据当前像素覆盖纹理的矩形大小，计算平均纹理值。

![](Media/Figure_06_05.png)

![](Media/Equation_06_02.png)

* SAT 在纹理的对角线上还是会有过度模糊的现象。
* 无约束各向异性过滤(Unconstrained Anisotropic Filtering)，可以进一步改善纹理过滤，对于屏幕上渲染的某像素，将其反向投影至纹理，得到纹理上的一个四边形，获取纹理中的几个正方形近似模拟该四边形，使用四边形的较短边获取mipmap的LOD级别，使用四边形的较长边创建一条平行于较长边且穿过四边形中间的各向异性线。当各向异性的大小在1：1和2:1之间时，沿着这条线采集两个样本，见下图，其他更高的各向异性比率时，则需要沿轴获取更多的样本, 这种方法可以在任意方向上运行，没有SAT的方向限制。

![](Media/Figure_06_06.png)

* Cube Map 使用三维纹理坐标，其中绝对值最大的坐标用于选择六个面中的其中一个面，而后另外两个纹理坐标除以该最大坐标的绝对值，并通过加1后除以2得到[0.0, 1.0] 之间的纹理坐标值。
* Texture atlas(纹理图集): 将多个图像放入一个较大的纹理中。注意其内的子纹理大小任意。注意mipmap的生成和访问问题。可能会包含单独不想关的图像mipmap生成问题, 可以通过将每个子纹理放入大型纹理图集之前分别为它们生成 mipmap 层次结构，且子纹理使用二次幂分辨率.
* Texture Arrays(纹理数组)，所有子纹理具有相同的尺寸，格式，mipmap层次结构和MSAA设置。没有 mipmapping 和 wrapping 模式的问题。
* Bindless texure(无绑定纹理)，之前的绑定纹理，绑定的纹理单元数量有上限。无绑定的纹理，使用一个64位的指针(pointer)关联一个纹理，或者称之为(handle)。可以多种方式访问该 handle，如 uniform 变量， varying data, 或者来自其他纹理，来自一个着色器存储缓存对象(shader storage buffer object, SSBO), 应用需要确保纹理位于GPU端内。无绑定纹理避免了任何驱动器内的绑定代价，使得渲染速度更快。
* S3 Texture Compression(S3TC) --- DX 选择的纹理压缩标准，称之为 DXTC， DX10 内称之为BC(Block Compression). 该标准也是 OpenGL 中实施中的标准。该纹理压缩的特点：大小固定，每个编码的部分之间独立，易于解码，不同压缩部分解码相互独立，不互相依赖。
* DXTC/BC 压缩方案有七个变体，BC1/DXT1、BC2/DXT3、BC3/DXT5、BC4、BC5、BC6H、BC7，这些方案在 4x4 的 texel 块上完成编码。对于每个编码块，存储两个参考值(如两个参考颜色值)，则4x4块中16个纹理像素每一个都保存一个插值因子，即在两个参考值中的某个插值结果作为该纹素的结果。注意变种名称中的 DXT 表示用于 DirectX 9 中。 
    - BC1 有两个 16 位的参考 RGB 颜色值(5位红色，6位绿色，5位蓝色)，每个纹素用2位的插值因子选择其中一个参考值或者两个参考值的中间值。 
    - BC2 的编码类似于 BC1, 但每个纹素额外4位用于量化(quantized-raw)的alpha值。
    - BC3编码类似于BC1，但 alpha 数据使用2个 8位的参考值编码，每个纹素使用3位的插值因子，即每个纹素可以选择其中一个alpha值，或者六个中间值的一个。
    - BC4 使用单个通道编码 BC3 中的 alpha 
    - BC5 使用两个通道。
    - BC6H 用于 HDR(high dynamic range) 纹理，每个 R，G,B通道有16位浮点数，使用16个字节，结果为 8bpt。
    - BC7 每块包含一到三行。仍属于 LDR 纹理。
* OpenGL 中， BC6H 和 BC7 分别为 BPTC_FLOAT 和 BPTC, 上述的压缩方案都属于有损压缩。OpenGL ES 使用 Ericsson texture compression(ETC, 爱立信纹理压缩)。 4x4 的纹素块编码为 64 位。每个 2x4块(或4x2块，取决于提供最佳质量的块)存储基色。每块从一个小的静态查找表中选择四个一组的常量，块中的每个纹理像素可以选择添加其中一个值改变其亮度。
* OpenGL ES 3.0 包含 ETC2，添加了更多的模式。 EAC(Ericsson alpha compression)使用一个分量(如alpha值)压缩图像。所有的ETC1, ECT2, EAC 都是 OpenGL 4.0 core profile, OpenGL3.0, Vulkan, Metal 的一部分。
* 压缩法线贴图，假设 z 分量为正。 z 分量等于 1.0 减去 x分量和y分量的平方和后的平方根。而且还可以把 x和y分量存储在BC5/3Dc-格式的纹理进一步压缩空间。如果硬件不支持BC5/3Dc或EAC格式，则使用 DXT5 格式，将x,y分量存储在绿色和alpha分量内，这是由于这两个分量存储精度最高。
* PVRTC 为在PowerVR的硬件上使用的纹理压缩格式，用于 iPhone, iPad. 每个纹理像素提供2位和4位的方案，并压缩 4x4 纹理像素的块，提供图像的两个低频(平滑)信号,该信号通过相邻的纹素数据块和插值获得，而后用1位或2位在两个信号之间插值。
* ASTC(Adaptive scalable texture compression)自适应可伸缩纹理压缩。使用128位表示nxm的像素块，nxm的范围位4x4到12x12之间。ASTC 可以处理纹理1-4个通道的任何通道组合，还可以处理 LDR,HDR纹理，ASTC是OpenGL ES 3.2 以及更高版本的一部分。压缩通常可以比解压花费的时间更长，因为解压可以用固定功能的硬件完成。
* 还可在不同的颜色空间中压缩纹理， 常见有 RGB-YCoCg, 下面列出两种转换方法

![](Media/Equation_06_03.png)

![](Media/Equation_06_04.png)

![](Media/Equation_06_05.png)

## 3 程序纹理(Procedural Texturing)
* 对于程序纹理，常见的技术是使用一个或多个噪值函数生成纹素的值。噪值函数通常在连续的二次方频率(八度)上进行采样，每个八度带有权重，其随着频率增加而降低，这些加权样本的总和称之为湍流函数(turbulence function)。

![](Media/Figure_06_07.png)

上图演示使用程序纹理生成的体纹理。左图通过ray maching渲染的半透明体纹理(见 shadertoy 的 “Playing marble”)，右图为在一个真实世界环境中使用程序木材的着色器生成的合成图像。

* 由于噪声函数的成本，可预先计算三维数组中的晶格点(lattice points), 而后使用纹理插值。
* 其他的程序纹理，如计算每个位置和空间中一组"特征点"的距离来生成细胞纹理。
* 物理模拟和交互过程也可以产生另外一种类型的程序纹理
* 程序纹理的抗锯齿，由于程序纹理的作者知道纹理内容的有关“内部信息”，因此可以对其进行裁剪以免走样。例如每个噪声函数的频率都已知，因此可以丢弃任何会引起走样的频率。

## 4 纹理动画
* 可以将视频作为纹理的来源，逐帧变化。
* 可以通过逐帧修改纹理坐标实现纹理动画。此外还可以在纹理坐标上应用矩阵变化，实现平移，缩放，旋转，切变，图像扭曲，变形变换等。
* 还可以使用纹理混合技术实现纹理的动画。

## 5 Material Mapping(材质贴图)
* 纹理主要用于改变着色方程中用到的材质属性。
* 纹理还可以控制片段着色器中的控制流和函数，例如通过纹理控制表面的哪些部分有哪些材质，不同的材质可以执行不同的着色器代码。例如带有生锈区域的金属表面可以用纹理设置生锈的位置，生锈部分执行生锈相关的着色器，其他部分则执行带光泽的金属着色器。

## 6 Alpha Mapping
* 下图演示贴花的实现，帧缓存内首先渲染场景，而后渲染盒子及其内的所有点，贴花的纹理被投影至帧缓存的内容上，可看到最顶部有四个纹素，最左边的是一个完全透明的纹素，无影响, 黄色的纹素则完全不可见。

![](Media/Figure_06_08.png)

* 还可使用单个矩形绘制富有复杂轮廓的物体，例如灌木丛。但换个角度看矩形时则会失效，此时可以围绕树干旋转90度再度绘制灌木。不过仍未解决从空中观看到错误内容的问题。
* alpha 贴图和纹理动画的结合产生惊艳的效果，如闪烁的火炬，植物的生长，爆炸，大气效果。
* alpha 混合排序的问题。有几种方法，比如 Alpha Testing, 在像素着色器中丢弃低于给地阈值的Alpha值的片段。