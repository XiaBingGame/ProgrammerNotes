# 《代码整洁之道》读书笔记

## 第2章 有意义的命名

* 如果名称需要注释来补充，那不就算是名副其实。
* 不使用数字字面常量。用有意义的名称表示
* 内置类型的数组使用别名表示
* 不要使用不同之处较小的名称
* 以数字序列(a1,a2,...,aN)命名是没有意义的区分. 废话是另外一种没有意义的区分. Info 和 Data 就像 a, an和the一样，都是意义含混的废话. 但可以用"a"做域内变量，"the"做函数参数。
* 变量名称要能够读出来。
* 变量名要长一点，方便搜索
* 匈牙利标记法容易引起误解，附带的类型缩写可能与当前的类型名不一致
* 类成员名不需要 "m_" 这样的前缀
* 名称不需要在脑中进行二次翻译
* 类名和对象名应该是名词或名词短语，方法名应当是动词或动词短语
* 可以用类的静态方法返回类对象的实例
* 不要用古怪的名称
* 每个概念对应一个词，如 fetch, retrieve, get 只取一个， controller, manager, driver 只取一个
* 一个单词不要有多个意思，add不要表示加法，又表示将一个元素加入一个容器。
* 尽量使用技术性名称，例如设计模式内的一般用语。 尽量用那些计算机科学术语，算法名，模式名，数学术语
* 使用源自所涉问题领域的名称
* 给名称添加有意义的语境。 addrFirstName, addrLastName, addrState
* 不要添加没用的语境

## 第3章 函数

* if 语句， else 语句， while 语句等， 其中的代码块应该只有一行，该行大抵应该是一个函数调用语句。函数不应该大到足以容纳嵌套结构， 函数的缩进层级不应该多于一层或两层。
* 函数应该做一件事情，做好这件事情，只做这一件事。
* 每个函数一个抽象层级。
* switch 语句最好只出现一次，用于创建多态对象。
* 泰半工作都在于为只做一件事的小函数取个好名字。
* 命名方式要保持一致，使用与模块名一脉相承的短语、名词和动词给函数命名。例如 includeSetupAndTeardownPages、includeSetupPages、includeSuiteSetupPage、includeSetupPage 等。
* 有足够特殊的理由才能用三个以上参数。
* 如果参数多于两个，测试覆盖所有可能值的组合简直让人生畏。
* 一元函数的普遍形式：1. 关于该参数的问题。 2. 操作该参数，将其转换为其他什么东西。
* 标志参数丑陋不堪，向函数传入布尔值简直就是骇人听闻的做法。
* 尽量利用一些机制将二元函数转换为一元函数。
* 如果函数看来需要两个、三个或三个以上参数，就说明其中一些参数应该封装成类。
* 对于一元函数，函数和参数应当形成一种非常良好的动词/名词对形式。例如 assertEqual 改成 assertExpectedEqualsActual(expected, actual) 可能会好些。
* 避免使用输出参数，如果函数必须要修改某种状态，就修改所属对象的状态。
* 函数要么做什么事，要么回答什么事，二者不可兼得。
* 使用异常代替返回错误码，错误处理代码就能从主路径代码中分离出来得到简化。
* 最好把 try 和 catch 代码块的主体部分抽离出来，另外形成函数。即 try 和 catch 块内只有一个函数。
* 使用异常代替错误码，新异常就可以从异常类派生出来，无需重新编译或重新部署。
* 软件开发领域的所有创新都是在不断尝试从源代码中消灭重复。

## 第4章 注释

* 注释的恰当用法是弥补我们在用代码表达意图时遭遇的失败。
* 程序员不能坚持维护注释。不准确的注释比没注释坏得多。
* 很多时候，简单到只需要创建一个描述与注释所言同一事物的函数即可。
* 注释不仅提供了有关实现的有用信息，而且还提供了某个决定后面的意图。
* 注释把某些晦涩难明的参数或返回值的意义翻译为某种可读形式。
* 用于警告其他程序员会出现某种后果的注释也是有用的。
* 定期查看 TODO 注释，删除不再需要的。
* 注释可以用来放大某种看来不合理之物的重要性。
* 写注释，就要花必要的时间确保写出最好的注释。
* 不要写多余的注释，不要写误导性的注释。不要写日志性注释(用版本控制写日志)
* 能用函数或者变量时就别用注释。
* 尽量少用标记栏，只在特别有价值的时候用。比如很长的 //// 符号。如果滥用标记栏，就会沉浸在背景噪音中。
* 把代码注释掉是讨厌的做法，使用版本控制保存之前的代码。
* 源代码注释中的HTML标记是一种厌物。
* 注释用来描述最近的代码。
* 别再注释中添加有趣的历史性话题或者无关的细节描述。
* 注释及其描述的代码之间的联系应该显而易见。

## 第5章 格式

* 根据统计，200行到500行之间的单个文件组成出色的系统。
* 每组代码行展示一条完整的思路，这些思路用空白行区别开来。有关联的相邻代码不要用空白行隔开。
* 不要把关系密切的概念放到不同的文件中，避免读者在源文件和类中跳来跳去。
* 变量声明应该尽可能靠近其使用位置。
* 循环中的控制变量应该总是在循环语句中声明。
* 相关函数，若某个函数调用了另外一个，就应该把它们放到一起，而且调用者应该尽可能放在被调用者上面。
* 常量不要埋藏在底层代码中。
* 概念相关的代码应该放在一起。
* 一行代码最长一般不要超过120个字符。
* 操作符左右添加空格符加强了分隔效果，不在函数名和左侧括号间加空格。括号中的参数用空格隔开。空格还可展示优先级， 如 b*b - 4*a*c
* 排在一起的大量参数不要尝试列对齐。
* 空范围使用括号括起来， 如 while(...) {;}

## 第6章 对象和数据结构

* 数据的隐藏与抽象有关。暴露抽象接口，用户无需了解数据的实现。
* 随便添加取值器和赋值器，是最坏的选择。
* 对象把数据隐藏于抽象之后，暴露操作数据的函数。数据结构暴露其数据，没有提供有意义的函数。
* 过程式代码(使用数据结构的代码)，便于在不改动既有数据结构的前提下添加新函数，面向对象代码便于在不改动既有函数的前提下添加新类。即过程式代码难以添加新数据结构，因为必须修改所有函数，面向对象代码难以添加新函数，因为必须修改所有类。

```
// 过程式代码
pubic class Square
{
    public Point topLeft;
    public double side;
}

public class Rectangle {
    public Point topLeft;
    public double height;
    public double width;
}

public class Circle {
    public Point center;
    public duble radius;
}

public class Geometry {
    public final double PI = 3.141592653589793

    public double area(Object shape) throw NoSuchShapeException {
        if ( shape instanceof Square){
            Square s = (Square)shape;
            return s.side * s.side;
        }
        else if ( shape instanceof Rectanble){
            Rectangle r = (Rectanble)shape;
            return r.width * r.height;
        }
        else if ( shape instanceof Circle){
            Circle c = (Circle)shape;
            return PI * c.radius * c.radius;
        }
        throw new NoSucheShapeException;
    }
}
```

* 得墨忒耳率(The Law of Demeter)。 类 C 的方法 f 只应该调用以下对象的方法, C 不应调用任何函数返回对象的方法，除非返回的不是对象而是数据结构。
    - C 本身
    - 由 f 创建的对象
    - 作为参数传递给 f 的对象
    - 由 C 实体变量持有的对象。

* 数据传送对象(DTO, Data Transfer Objects)，是一个只有公共变量，没有函数的类。DTO 是非常有用的结构，尤其是在数据通信，或解析套接字传递的消息之类场景中。

## 第7章 错误处理

* 在编写可能抛出异常的代码时，最好先写出 try-catch-finally 语句。 这能帮你定义代码的用户应该期待什么， 无论 try 代码块中执行的代码出什么错都一样。
* 可控异常的代价就是违反开放闭合原则(可控异常--函数签名中包括抛出的可能异常)。
* 应创建信息充分的错误消息，并和异常一起传递出去。在消息中，包括失败的操作和失败类型，如果你的程序有日志系统，传递足够的信息给 catch 块，并记录下来。
* 如果你打算在方法中返回 null 值，不如抛出异常，或是返回特例对象。如果你在调用某个某个第三方 API 中可能返回 null 值的方法，可以考虑用新方法打包这个方法，在新方法中抛出异常或返回特例对象。在许多情况下，特例对象都是爽口良药。
* 除非 API 要求你向它传递 null 值，否则就要尽可能避免传递 null 值。

## 第8章 边界

* 不要在生产代码中试验新东西，而是编写测试来遍览和理解第三方代码。测试聚焦于我们想从 API 得到的东西。Jim Newkirk 把这叫做学习性测试。
* 学习性测试帮助我们增进对 API 的理解。当第三方程序包发布了新版本，我们可以运行学习性测试，看看程序包的行为有没有改变。

## 第9章 单元测试

* TDD 三定律
    - 定律一： 在编写不能通过的单元测试前，不可编写生产代码
    - 定律二： 只可编写刚好无法通过的单元测试，不能编译也算不通过
    - 定律三： 只可编写刚好足以通过当前失败测试的生产代码。
* 生产代码和测试一起编写，测试只比生产代码早些几分钟，这样反复循环编写代码。
* 测试越脏，测试代码就越难修改。测试代码和生产代码一样重要。
* 单元测试让你的代码可扩展，可维护，可复用。
* 单元测试代码主要用构造-操作-检验（BUILD-OPERATE-CHECK) 模式。每个测试都清晰地拆分为三个环节，第一个环节构造测试数据，第二个环节操作测试数据，第三个环节检验操作是否得到期望的结果。
* 每个测试函数应该有且只有一个断言语句。每个测试函数只测试一个概念。
* 整洁的测试遵循五个规则
    - 快速(FIRST)
    - 独立(Independent): 测试不互相依赖。
    - 可重复(Repeatable)
    - 自足验证(Self-Validating): 测试应该有布尔输出，无论是通过或失败，都不应该查看日志文件来确认测试是否通过。
    - 及时(Timely): 及时编写。在生产代码之前编写

## 第10章 类

* 类应该足够短小。
* 类的名称应该描述其权责，如果无法为某个类命以精确的名称，这个类大概就太长了。如果类名中包括含义模糊的词，如 Processor 或 Manager 或 Super, 这种现象往往说明有不恰当的权责聚集情况存在。
* 单一权责原则(SRP), 类和模块应有且只有一条加以修改的理由。
* 通常而言，方法操作的变量越多，就越粘聚到类上。如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。内聚性高，意味着类中的方法和变量互相依赖，互相结合成一个逻辑整体。
* 保持函数和参数列表短小的策略，有时会导致为一组子集方法所用的实体变量(类成员变量)数量增加，出现这种情况，往往意味着至少有一个类要从大类中挣扎出来。将大函数拆分为许多小函数，往往也是将类拆分为许多小类的时机。