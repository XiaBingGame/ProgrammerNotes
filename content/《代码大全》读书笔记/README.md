<!--
 * @Author: summericeyl summericeyl@gmail.com
 * @Date: 2024-05-05 20:11:13
 * @LastEditors: summericeyl summericeyl@gmail.com
 * @LastEditTime: 2024-05-19 22:12:04
 * @FilePath: \undefinedf:\Articles\Github\ProgrammerNotes\content\《代码大全》读书笔记\README.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->
# 第3章 谋定而后动: 前期准备
* 一个常见的经验法则: 预先确定大约80%的需求, 为以后再确定的额外需求预留时间, 然后采用系统化的变更控制, 以确保随着项目的进展只接受最有价值的新需求. 另一种选择是预先确定最重要的 20% 需求, 并计划以小的增量来开发软件的其余部分, 然后随着时间的推移来确定新增的需求和设计
* 问题定义只定义了问题是什么, 并不涉及任何可能的解决方案
* 问题定义要使用用户的语言, 并且应该从用户的角度描述问题
* 未能定义问题的后果是, 可能会浪费大量时间来解决错误的问题
* 明确的需求能免得我们去猜用户到底想要什么
* 需求检查清单,检查项目的需求工作做的如何
    - 具体的功能需求
      - 是否指定了系统的所有输入，包括其来源、精度、值的范围和出现频率？
      - 是否指定了系统的所有输出，包括其目标、精度、值的范围、出现频率和格式？
      - 是否为 Web 页面和报表等指定了所有输出格式？
      - 是否指定了所有外部硬件和软件接口？
      - 是否指定了所有外部通信接口，包括握手、错误检查和通信协议？
      - 是否指定了用户想要执行的所有任务？
    - 特定的非功能性(质量)需求
        - 从用户的角度来看，是否为所有必要的操作指定了预期的响应时间？
        - 是否指定了其他时间考虑因素,比如处理时间,数据传输速率和系统吞吐量?
        - 是否指定了安全级别?
        - 是否指定了可靠性,包括软件故障的后果,需要在故障中得到保护的重要信息以及错误检测和恢复策略
        - 是否指定了最小机器内存和空闲磁盘空间?
        - 是否指定了系统的可维护性,包括适应特定功能的更改、操作环境的更改以及与其他软件接口的更改的能力？
        - 是否包含了成功和失败的定义？
    - 需求质量
        - 需求是用用户的语言编写的吗？用户这么认为吗？
        - 每个需求都避免了与其他需求的冲突吗？
        - 是否详细说明了竞争属性之间的可接受的折中，例如健壮性和正确性的折中？
        - 是否避免了在需求中规定设计？
        - 需求再详细程度上是一致的吗？是否有需求需要更详细的说明？是否有需求不需要那么详细的说明？
        - 需求是否足够清晰，以至于可以移交给一个独立的团队进行构建，且不会产生误解？开发人员这么认为吗？
        - 每个条款都与待解决的问题机器解决方案相关吗？能从每个条款上溯到在问题域中对应的根源吗？
        - 每个需求都是可测试的吗？是否有可能通过进行独立测试来确定每个需求都被满足了？
        - 是否说明了需求的所有可能变更以及每种变更的可能性？
    - 需求的完整性
      - 对于在开发中无法获得的信息，是否详细描述了信息不完全的区域？
      - 需求的完备程度是否可以达到这种程度，如果产品满足所有需求，就说明它是可接受的？
      - 对全部需求都感到满意吗？是否已经去掉了那些不可能实现的需求，那些只是为了安抚客户和老板的东西。
* 软件架构是软件设计的高层部分,通常使用"架构规格书"或者"顶层设计", 架构和顶层设计的区分: 架构是指适用于整个系统范围的设计约束, 而高层设计是指适用于子系统层次或者多个类的层次上的设计约束(但不是整个系统范围的设计)
* 需要考虑的20个架构元素:
  - 程序的组织
    - 系统架构首先要以概括的形式对系统做一个综述
    - 并阐述选择该组织结构的理由
    - 架构应当定义系统主要的组件
    - 明确定义各个组件的责任, 每个组件应该负责某个区域的事情, 并且对其他组件负责的区域, 知道的越少越好
    - 明确定义每个组件的通信原则, 对于每个组件, 架构应当能够描述它能直接使用哪些组件, 能间接使用哪些组件, 以及不能使用哪些组件
  - 主要的类
    - 详细定义所使用的主要的类
    - 指出每个主要的类的责任及如何与其他类交互
    - 包含对类的继承体系、状态转换以及对象持久化等的描述。如果系统足够大，那么应当描述如何将这些类组织成一个个子系统
    - 对构成系统80%的行为的20%的类进行详细说明
  - 数据设计
    - 描述所用到的主要文件和数据表的设计，说明使用该方案的理由。
    - 例如使用顺序访问的列表保存ID表，为什么比随机访问的列表和堆栈更好
  - 业务规则
    - 描述业务规则对系统架构的影响
  - 用户界面设计
    - 用户界面常常在需求阶段进行详细说明。如果没有，就应当在软件架构中进行详细说明。
    - 架构应该模块化，在用户界面替换时不影响业务规则和程序的输出部分。
  - 资源管理
    - 描述一份管理稀缺资源的计划，稀缺资源包括数据库连接、线程、句柄等，以及内存。
  - 安全性
    - 描述实现设计层面和代码层面安全性的方法,在架构阶段或之前建立威胁模型. 如考虑处理缓冲区的方法, 处理不可信数据的规则等
  - 性能
    - 如关注性能,则在需求中详细定义性能目标.
  - 可伸缩性
    - 可伸缩性是系统增长以满足未来需求的能力.
  - 互操作性
    - 系统与其他软件或硬件共享数据或资源
  - 国际化(本地化)
  - 输入/输出
    - 如读取策略是先查看(look-ahead), 后查看(look-behind), 及时查看(just-in-time). 在哪一层检测 I/O 错误: 字段、记录、流或文件的层次。
  - 错误处理
    - 最好上升到架构层面上来建立一个错误处理策略, 考虑的问题：
      - 错误处理是进行纠正，还是仅仅进行检测？
      - 错误检测是主动的还是被动？
      - 程序如何传播错误？
      - 错误消息的处理有什么约定？
      - 如何处理异常？
      - 在程序中，在什么层次上处理错误？
      - 每个类在验证其输入数据的有效性方面需要负何种责任？
      - 你是希望用运行环境中内建的错误处理机制，还是想建立自己的一套机制？
  - 容错性
    - 定义所期望的容错种类，包括检测错误，如果可能就从错误中恢复。如果不能从错误中恢复，就包容其不利影响。
    - 容错策略：
      - 系统在检测到错误的时候退回去，再试一次。
      - 系统拥有一套辅助代码，以备在主代码出错的时候使用。
      - 系统使用一种投票算法，算出多个结果，使用均值、中值或模数作为最终结果
      - 系统使用某个不会对系统其余部分产生危害的虚假值代替这个错误的值
      - 转入其他运转的状态，或转入某种功能降级的状态。系统可以自动关闭或重启。